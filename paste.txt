"""

print("Initializing TTS Engine...")

kwargs = {
    'stdout':subprocess.PIPE,
    'stderr':subprocess.PIPE,
    'stdin':subprocess.PIPE
}

class tts_runner:
    def __init__(self, use_p1: bool=False, log: bool=False):
        self.log = log
        
        if use_p1:
            self.emb = torch.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models\emb\glados_p1.pt')
        else:
            self.emb = torch.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models\emb\glados_p1.pt')
        # Select the device
        if torch.cuda.is_available():
            self.device = 'cuda'
        elif torch.is_vulkan_available():
            self.device = 'vulkan'
        else:
            self.device = 'cpu'

        # Load models
        self.glados = torch.jit.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models/glados-new.pt')
        self.vocoder = torch.jit.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models/vocoder-gpu.pt', map_location=self.device)
        for i in range(2):
            init = self.glados.generate_jit(prepare_text(str(i)), self.emb, 1.0)
            init_mel = init['mel_post'].to(self.device)
            init_vo = self.vocoder(init_mel)

    def run_tts(self, text, alpha: float=1.0) -> AudioSegment:
        x = prepare_text(text)

        with torch.no_grad():

            # Generate generic TTS-output
            old_time = time.time()
            tts_output = self.glados.generate_jit(x, self.emb, alpha)
            if self.log:
                print("Forward Tacotron took " + str((time.time() - old_time) * 1000) + "ms")

            # Use HiFiGAN as vocoder to make output sound like GLaDOS
            old_time = time.time()
            mel = tts_output['mel_post'].to(self.device)
            audio = self.vocoder(mel)
            if self.log:
                print("HiFiGAN took " + str((time.time() - old_time) * 1000) + "ms")

            # Normalize audio to fit in wav-file
            audio = audio.squeeze()
            audio = audio * 32768.0
            audio = audio.cpu().numpy().astype('int16')
            output_file = tempfile.TemporaryFile()
            write(output_file, 22050, audio)
            sound = AudioSegment.from_wav(output_file)
            output_file.close()
            return sound

    def speak_one_line(self, audio, name: str):
        audio.export(name, format = "wav")
        if 'winsound' in mod:
            winsound.PlaySound(name, winsound.SND_FILENAME | winsound.SND_ASYNC)
        else:
            try:
                subprocess.Popen(["play", name], **kwargs)
            except FileNotFoundError:
                try:
                    subprocess.Popen(["aplay", name], **kwargs)
                except FileNotFoundError:
                    subprocess.Popen(["pw-play", name], **kwargs)

    def speak(self, text, alpha: float=1.0, save: bool=False, delay: float=0.1):
        download('punkt',quiet=self.log)
        sentences = sent_tokenize(text)
        audio = self.run_tts(sentences[0])
        pause = AudioSegment.silent(duration=delay)
        
        old_line = AudioSegment.silent(duration=1.0) + audio
        old_time = time.time()
        old_dur = old_line.duration_seconds
        new_dur = old_dur
        
        if len(sentences) > 1:
            for idx in range(1, len(sentences)):
                if idx % 2 == 1:
                    new_line = self.run_tts(sentences[idx])
                    audio = audio + pause + new_line
                    new_dur = new_line.duration_seconds
                else:
                    old_line = self.run_tts(sentences[idx])
                    audio = audio + pause + old_line
                    new_dur = old_line.duration_seconds
                time_left = old_dur - time.time() + old_time
                if time_left <= 0 and self.log:
                    print("Processing is slower than realtime!")
                else:
                    time.sleep(max(time_left + delay, 0))
                old_time = time.time()
                old_dur = new_dur
        else:
            time.sleep(old_dur + 0.1)
        
        output_name = "output.wav"
        audio.export(output_name, format="wav")

        # Comment out this
        # Playing the final audio
        self.speak_one_line(audio, output_name)
        time_left = old_dur - time.time() + old_time
        if time_left >= 0:
            time.sleep(time_left + delay)
        
        
        
if __name__ == "__main__":
    glados = tts_runner(False, True)
    while True:
        text = input("Input: ")
        if len(text) > 0:
            glados.speak(text, True)

            
"""



"""

class TTSRunner:

    def __init__(self, use_p1: bool = False, log: bool = False):
        self.log = log
        self.playing = False  
        pygame.mixer.init()

        if use_p1:
            self.emb = torch.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models\emb\glados_p1.pt')
        else:
            self.emb = torch.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models\emb\glados_p1.pt')
        # Select the device
        if torch.cuda.is_available():
            self.device = 'cuda'
        elif torch.is_vulkan_available():
            self.device = 'vulkan'
        else:
            self.device = 'cpu'

        # Load models
        self.glados = torch.jit.load(r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models/glados-new.pt')
        self.vocoder = torch.jit.load(
            r'C:\Users\mcovi\source\repos\Glados-tts\glados-tts\models/vocoder-gpu.pt', map_location=self.device)
        for i in range(2):
            init = self.glados.generate_jit(prepare_text(str(i)), self.emb, 1.0)
            init_mel = init['mel_post'].to(self.device)
            init_vo = self.vocoder(init_mel)

    def run_tts(self, text, alpha: float = 1.0) -> str:
        x = prepare_text(text)
        temp_wav_file = tempfile.NamedTemporaryFile(suffix=".wav", delete=False)

        with torch.no_grad():

            # Generate generic TTS-output
            old_time = time.time()
            tts_output = self.glados.generate_jit(x, self.emb, alpha)
            if self.log:
                print("Forward Tacotron took " + str((time.time() - old_time) * 1000) + "ms")

            # Use HiFiGAN as vocoder to make output sound like GLaDOS
            old_time = time.time()
            mel = tts_output['mel_post'].to(self.device)
            audio = self.vocoder(mel)
            if self.log:
                print("HiFiGAN took " + str((time.time() - old_time) * 1000) + "ms")

            # Normalize audio to fit in wav-file
            audio = audio.squeeze()
            audio = audio * 32768.0
            audio = audio.cpu().numpy().astype('int16')

            # Save the audio to a temporary WAV file
            write(temp_wav_file.name, 22050, audio)

        return temp_wav_file.name  # Return the path to the temporary WAV file

    def speak_one_line(self, audio_path, name: str):
        # Function to play audio from a file
        pygame.mixer.music.load(audio_path)
        pygame.mixer.music.play()
        while pygame.mixer.music.get_busy():
            pygame.time.delay(100)  # Adjust the delay as needed
        
        

    def play_audio_thread(self, audio_path, name):
        # Function to play audio in a separate thread
        self.playing = True
        print(f"from play_audio_thread before speak, self.playing is {self.playing}" + '\n')
        self.speak_one_line(audio_path, name)
        self.playing = False
        print(f"from play_audio_thread after speak, self.playing is {self.playing}" + '\n')


    def speak(self, text, alpha: float = 1.0, save: bool = False, delay: float = 10):
        download('punkt', quiet=self.log)
        sentences = sent_tokenize(text, language="english")

        for idx, sentence in enumerate(sentences):
            audio_path = self.run_tts(sentence)
            output_name = f"output{idx + 1}.wav"
            
            # Start a separate thread to play audio if not already playing
            if (self.playing == False):
                print(f"Multi-threaded check: self.playing is {self.playing}" + '\n')
                playback_thread = threading.Thread(target=self.play_audio_thread, args=(audio_path, output_name))
                playback_thread.start()

                
"""